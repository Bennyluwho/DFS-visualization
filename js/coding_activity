/* -------------------- CODING ACTIVITY: runner only (UI is controlled by setUIMode) -------------------- */

document.addEventListener('DOMContentLoaded', () => {
  const runBtn   = document.getElementById('run-python');
  const clearBtn = document.getElementById('clear-output');
  const outEl    = document.getElementById('py-output');

  if (clearBtn && outEl) {
    clearBtn.addEventListener('click', () => {
      outEl.textContent = '';
      outEl.style.display = 'block';
    });
  }

  if (runBtn && outEl) {
    runBtn.addEventListener('click', async () => {
      const code = buildUserCode();
      outEl.style.display = 'block';
      outEl.textContent = 'Running…';
      await ensureWorker();
      runWithTimeout(code, outEl);
    });
  }
});

/* -------------------- Code assembly from blanks (simple sanitize) -------------------- */
function buildUserCode() {
  const blanks = Array.from(document.querySelectorAll('#coding-activity .blank')).map(x => (x.value || '').trim());
  const safe = blanks.map(s => s.replace(/[^A-Za-z0-9_\[\]\(\)\{\}\.\,\s'":]/g, ''));
  const [BLANK1, BLANK2] = safe;

  return `
def dfs(graph, start):
    visited = set()
    stack = [${BLANK1}]
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            stack.extend(${BLANK2})
    return visited

# --- tests (hidden) ---
def _run_tests():
    g1 = {'A':['B','C'], 'B':['D'], 'C':[], 'D':[]}
    out1 = dfs(g1, 'A')
    assert out1 == {'A','B','C','D'}

    g2 = {'1':['2','3'], '2':['4'], '3':['4'], '4':[]}
    out2 = dfs(g2, '1')
    assert out2 == {'1','2','3','4'}

    g3 = {'X':['Y'], 'Y':[], 'Z':[]}  # disconnected
    out3 = dfs(g3, 'X')
    assert out3 == {'X','Y'}

    return "All tests passed! " + str(sorted(out1))

print(_run_tests())
`;
}

/* -------------------- Pyodide Worker plumbing with timeout -------------------- */
let pyWorker = null;
let pyReady  = false;

async function ensureWorker() {
  if (pyWorker && pyReady) return;
  pyWorker = createWorker();
  pyReady = false;
  await new Promise((resolve) => {
    const onMsg = (e) => {
      if (e && e.data && e.data.ready) {
        pyReady = true;
        pyWorker.removeEventListener('message', onMsg);
        resolve();
      }
    };
    pyWorker.addEventListener('message', onMsg);
    pyWorker.postMessage({ type: 'init' });
  });
}

function createWorker() {
  const code = `
    let pyodide;
    self.onmessage = async (e) => {
      const { type, code } = e.data || {};
      try {
        if (type === 'init') {
          importScripts('https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js');
          pyodide = await loadPyodide({ stdin: () => "" });
          // Block imports for safety
          await pyodide.runPythonAsync(\`
import builtins
def _blocked_import(*args, **kwargs):
    raise ImportError("Imports are disabled for this exercise")
builtins.__import__ = _blocked_import
\`);
          postMessage({ ok: true, ready: true });
          return;
        }
        if (type === 'run') {
          const wrapped = \`
import io, sys, contextlib
buf = io.StringIO()
with contextlib.redirect_stdout(buf):
\${code}
out = buf.getvalue()
\`;
          await pyodide.runPythonAsync(wrapped);
          let res = pyodide.globals.get('out');
          if (res && typeof res.toJs === 'function') res = res.toJs();
          else if (res && typeof res.toString === 'function') res = res.toString();
          postMessage({ ok: true, output: String(res || '') });
        }
      } catch (err) {
        postMessage({ ok: false, error: String(err) });
      }
    };
  `;
  const blob = new Blob([code], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
}

function runWithTimeout(code, outEl) {
  if (!pyWorker || !pyReady) {
    outEl.style.display = 'block';
    outEl.textContent = 'Runtime not ready. Try again.';
    return;
  }
  outEl.style.display = 'block';
  outEl.textContent = 'Running tests…';

  const TIME_LIMIT_MS = 3000;
  let settled = false;

  const onMsg = (e) => {
    if (settled) return;
    settled = true;
    const { ok, output, error } = e.data || {};
    if (ok) outEl.textContent = output || '(no output)';
    else    outEl.textContent = 'Error: ' + error;
    pyWorker.removeEventListener('message', onMsg);
  };

  pyWorker.addEventListener('message', onMsg);
  pyWorker.postMessage({ type: 'run', code });

  setTimeout(() => {
    if (settled) return;
    settled = true;
    outEl.textContent = '⏱️ Time limit exceeded (3s). Check for infinite loops.';
    try { pyWorker.terminate(); } catch (_) {}
    pyWorker = null;
    pyReady  = false;
  }, TIME_LIMIT_MS);
}
