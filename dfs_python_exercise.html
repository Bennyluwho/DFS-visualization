<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DFS – Python Fill‑in‑the‑Blank Exercise (Import Block Fix)</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.5; padding: 24px; }
    h1 { margin: 0 0 6px; font-weight: 700; }
    .sub { color: #666; margin: 0 0 16px; }
    .toolbar { display: flex; gap: 8px; align-items: center; margin: 12px 0 16px; flex-wrap: wrap; }
    .btn { cursor: pointer; border: 1px solid #bbb; padding: 8px 12px; border-radius: 10px; background: transparent; }
    .btn.primary { border-color: #888; font-weight: 600; }
    pre.code { background: rgba(127,127,127,0.08); padding: 12px; border-radius: 12px; white-space: pre-wrap; overflow-x: auto; }
    input.blank { border: 1px solid #bbb; border-radius: 6px; padding: 2px 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #py-output { min-height: 1.6em; margin-top: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hint { font-size: 0.95rem; color: #555; margin-top: 6px; }
  </style>
</head>
<body>
  <h1>DFS – Python Fill‑in‑the‑Blank</h1>
  <p class="sub">Fill the two blanks and press <b>Run</b>. Your code runs safely in the browser using Pyodide inside a Web Worker.</p>

  <section id="py-exercise">
    <pre class="code">
def dfs(graph, startNode):
    visited = set()
    stack = [<input class="blank" size="8" aria-label="initial push" placeholder="start">]
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            # push neighbors (optionally reversed) so left-most comes out first
            stack.extend(<input class="blank" size="18" aria-label="neighbors" placeholder="graph[node]">)
    return visited
    </pre>

    <div class="toolbar">
      <button id="run-python" class="btn primary">Run</button>
      <button id="reset-python" class="btn">Reset blanks</button>
      <button id="fill-correct" class="btn" title="Autofill correct answers">Fill correct</button>
    </div>

    <div id="py-output" aria-live="polite"></div>
    <div class="hint">Tip: Typical answers are <code>startNode</code> and <code>graph[node]</code>. You can also try <code>reversed(graph[node])</code>.</div>
  </section>

  <script>
  (function () {
    const section = document.getElementById('py-exercise');
    const runBtn = document.getElementById('run-python');
    const resetBtn = document.getElementById('reset-python');
    const fillBtn = document.getElementById('fill-correct');
    const outEl = document.getElementById('py-output');

    function buildUserCode() {
      const blanks = Array.from(section.querySelectorAll('.blank')).map(x => x.value.trim());
      const safe = blanks.map(s => s.replace(/[^A-Za-z0-9_\\[\\]\\(\\)\\{\\}\\.,\\s'":\\-]/g, ''));
      const [BLANK1, BLANK2] = safe;
      return `
def dfs(graph, startNode):
    visited = set()
    stack = [${BLANK1}]
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            stack.extend(${BLANK2})
    return visited

# --- tests (hidden to learners) ---
def _run_tests():
    g = {'A':['B','C'], 'B':['D'], 'C':[], 'D':[]}
    out = dfs(g, 'A')
    assert out == {'A','B','C','D'}
    return "All tests passed! Visited: " + str(sorted(out))

print(_run_tests())
`;
    }

    let pyWorker = null;
    let ready = false;

    function createWorker() {
      const workerCode = `
        let pyodide;
        self.onmessage = async (e) => {
          const { type, code } = e.data;
          try {
            if (type === 'init') {
              importScripts('https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js');
              pyodide = await loadPyodide({stdin:()=>""});
              // NOTE: Do NOT block imports here. We'll block them only during user code execution.
              postMessage({ ok: true, ready: true });
              return;
            }
            if (type === 'run') {
              // Indent the user's code so it's inside the 'with' block
              const indent = (s) => s.split('\\n').map(line => '    ' + line).join('\\n');
              const codeIndented = indent(code);

              const wrapped = \`
# Import our utilities BEFORE blocking import
import builtins, io, sys, contextlib
# Save and then block import only for user code
_orig_import = builtins.__import__
def _blocked_import(*args, **kwargs):
    raise ImportError("Imports are disabled for this exercise")
buf = io.StringIO()
try:
  builtins.__import__ = _blocked_import
  with contextlib.redirect_stdout(buf):
\${codeIndented}
  out = buf.getvalue()
finally:
  builtins.__import__ = _orig_import
\`;
              await pyodide.runPythonAsync(wrapped);
              const res = pyodide.globals.get('out');
              postMessage({ ok: true, output: res });
            }
          } catch (err) {
            postMessage({ ok: false, error: String(err) });
          }
        };
      `;
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    }

    async function ensureWorkerReady() {
      if (pyWorker && ready) return true;
      outEl && (outEl.textContent = 'Loading Python runtime…');
      pyWorker = createWorker();
      return await new Promise((resolve) => {
        pyWorker.onmessage = (e) => {
          const { ok, ready: r, output, error } = e.data || {};
          if (r) { ready = true; outEl.textContent = 'Runtime ready.'; resolve(true); }
          else if (ok) { outEl.textContent = output || '(no output)'; }
          else { outEl.textContent = 'Error: ' + error; }
        };
        pyWorker.onerror = (e) => {
          outEl.textContent = 'Worker error: ' + (e.message || e.filename || e.lineno || 'unknown');
        };
        pyWorker.postMessage({ type: 'init' });
      });
    }

    runBtn && runBtn.addEventListener('click', async () => {
      const code = buildUserCode();
      outEl.textContent = 'Running…';
      await ensureWorkerReady();

      const TIME_LIMIT_MS = 3000;
      let timedOut = false;
      const timer = setTimeout(() => {
        timedOut = true;
        outEl.textContent = '⏱️ Time limit exceeded (3s). Check for infinite loops.';
        if (pyWorker) pyWorker.terminate();
        pyWorker = null; ready = false;
      }, TIME_LIMIT_MS);

      const clearOnMsg = () => { clearTimeout(timer); };
      pyWorker && pyWorker.addEventListener('message', clearOnMsg, { once: true });

      pyWorker && pyWorker.postMessage({ type: 'run', code });
    });

    resetBtn && resetBtn.addEventListener('click', () => {
      const blanks = section.querySelectorAll('.blank');
      blanks.forEach((b) => b.value = '');
      outEl.textContent = '';
    });

    fillBtn && fillBtn.addEventListener('click', () => {
      const blanks = section.querySelectorAll('.blank');
      blanks.forEach((b, i) => b.value = i === 0 ? 'startNode' : 'graph[node]');
      outEl.textContent = 'Filled with a correct example. Press Run.';
    });

    // Prefill with correct answers for a smooth first run
    fillBtn && fillBtn.click();
  })();
  </script>
</body>
</html>
